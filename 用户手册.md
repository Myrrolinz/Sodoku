# 数独控制台程序

- 姓名：管昀玫、石家琪
- 学号：2013750、2011739
- 专业：计算机科学与技术

> 前言：
>
> 在我们的程序中，已实现所有6个要求的功能，包括：
>
> - 生成数独游戏
> - 求解数独游戏
> - 不同难度，保证唯一解，限制挖空范围
>
> 除此之外，我们的程序允许参数乱序，即不固定`-n/-m/-u`或`-n/-r/-u`的相对位置，为参数的输入提供了便利。

## 用户手册

### 1 程序简介

欢迎使用我们的数独控制台程序！该程序为数独爱好者提供了多项实用功能，包括生成数独终盘、求解数独、批量生成数独游戏以及灵活的游戏定制选项。

通过生成数独终盘功能，您可以获得一个全新的数独谜题的终盘，即完整的已填数字的数独板。这个终盘可以作为一个随机数独游戏的基础，让您在每次游戏时都能体验到不同的挑战和解谜乐趣。

同时，该程序也提供了求解数独的功能。如果您遇到难题或想验证自己的解答是否正确，只需将数独谜题输入程序，它将为您快速求解并给出答案。

除此之外，我们的控制台程序还支持批量生成数独游戏，让您可以一次性获得多个数独谜题。您可以指定生成游戏的难度级别，选择简单、中等或困难的谜题，以适应不同的游戏水平和挑战需求。

定制化选项也是我们程序的亮点之一。您可以指定生成游戏中挖空的数量范围，从较少的空格数到更多的空格数，根据自己的喜好和难度偏好定制游戏体验。此外，您还可以选择生成游戏时的解唯一要求，确保每个数独谜题都有唯一的解决方案。

我们希望通过使用我们的数独控制台程序，您可以尽情享受数独的乐趣，锻炼逻辑思维和推理能力。如果您有任何问题或需要支持，请随时与我们联系。祝您玩得愉快并挑战成功！

## 2 安装与运行

1. 下载程序：请前往我们的[GitHub](https://github.com/civilizwa/shudu/tree/master)，获取数独控制台程序的exe文件。
2. 解压文件：将下载的安装文件解压到您希望安装程序的目录。
3. 打开控制台：打开操作系统的命令提示符（Windows系统为命令提示符，Linux和macOS系统为终端）。
4. 切换目录：使用命令提示符（或终端）中的`cd`命令，切换到数独控制台程序的exe所在目录。默认情况下，目录为：`shudu\x64\Release`
5. 运行程序：在命令提示符（或终端）中输入程序的可执行文件名称，并指定参数信息，按下回车键运行程序。
6. 指定文件位置参数：在运行程序时，使用命令行参数指定数独谜题文件的位置。根据程序的要求，可能需要输入文件的完整路径或相对路径。请根据程序的使用说明提供正确的文件位置参数。

如果您在安装和运行过程中遇到任何问题，请参阅程序的用户手册或联系我们的支持团队获取帮助。

祝您愉快地安装和运行数独控制台程序，并享受解谜的乐趣！

### 3 界面介绍

我们的数独控制台程序提供了简洁而直观的界面，使您能够轻松操作和享受数独游戏的乐趣。

1. 命令输入：命令输入是数独游戏中最重要的部分，具体参数详见后文介绍。通过命令输入，可以指定需要的数独终盘数量、需要解的数独棋盘文件路径、需要的游戏数量、生成的游戏难度、生成游戏的难度、唯一解等。
2. 提示信息：程序通常会在界面中显示一些操作提示，指导您如何与数独进行交互，如提示输入路径、输入错误警告、开始生成若干数独终盘等。请仔细阅读和遵循这些提示，以正确地操作数独游戏。
3. 进度条显示：在批量进行数独操作时，我们提供进度条显示，以帮助用户直观地感受程序进度。在进度条尾部，还会显示`op/s`、操作结束时间、经历时长等信息。
4. 结果显示：在求解数独或执行其他操作后，程序会在界面中显示相应的结果。这可能是数独的解答、生成的数独游戏、操作的成功或失败消息等。请注意仔细阅读结果显示，以获取所需的信息。

### 4 使用指南

在`shudu.exe`目录下打开命令行窗口，输入如下格式的命令：

`````c++
shudu.exe [parameters]
`````

注意，每一次运行，都要填入txt文件所在或生成的绝对路径，下面给出示例：

#### 4.1 生成数独终盘

使用参数`-c`，并指定数目，即可生成数独终盘

| [para]  | -c                                   |
| :------ | :----------------------------------- |
| mean    | 需要生成的数组终盘数量               |
| range   | 1-1000000                            |
| example | shudu.exe -c 20 【生成20个数独终盘】 |

![image-20230628201551219](Pic/image-20230628201551219.png)

#### 4.2 读取游戏并给出解答

使用参数`-s`，读取若干数独游戏并给出解答

| [para]     | -s                                                           |
| :--------- | :----------------------------------------------------------- |
| mean       | 需要解的数组棋盘文件路径                                     |
| limitation | 绝对或者相对路径                                             |
| example    | shudu.exe -s game.txt 【从game.txt读取若干个数独游戏，并给出解答，生成到sudoku.txt中】 |

`question.txt`示例：使用`$`符号代表待填的空

![image-20230628202036707](Pic/image-20230628202036707.png)

命令程序进行求解：

![image-20230628201853726](Pic/image-20230628201853726.png)

求解完成后，该目录下出现`ans.txt`：

![image-20230628201937004](Pic/image-20230628201937004.png)

`ans.txt`内容为求解完成的数独解答：

![image-20230628202058967](Pic/image-20230628202058967.png)

#### 4.3 批量生成数独游戏

使用参数`-n`，并指定需要的游戏数量，即可批量生成数独

| [para]  | -n                                       |
| :------ | :--------------------------------------- |
| mean    | 需要的游戏数量                           |
| range   | 1-10000                                  |
| example | shudu.exe -n 1000 【生成1000个数组游戏】 |

![dc2f94f64875803a43c9fdc0dd73026](Pic/dc2f94f64875803a43c9fdc0dd73026.png)

生成的`question.txt`如下所示，以`$`来代替待填的数字：

<img src="Pic/7e029ecfe6e076b09343eebbbcc5026.png" alt="7e029ecfe6e076b09343eebbbcc5026" style="zoom:67%;" />

#### 4.4 生成游戏的难度

使用参数`-n`和`-m`，需要指定生成游戏的数量和难度，难度为数字1~3之间，数字越大代表越难

| [para]  | -m                                                           |
| :------ | :----------------------------------------------------------- |
| mean    | 生成游戏的难度                                               |
| range   | 1-3                                                          |
| example | shudu.exe -n 1000 -m 1 【生成1000个简单数独游戏，只有m和n一起使时才认为参数无误，否则请报错】 |

尝试生成难度1：

![3615fafbae86ee2ab68a8921ddb6eb2](Pic/3615fafbae86ee2ab68a8921ddb6eb2.png)

<img src="Pic/c2ae4429c3b3ecc8caa194b259090b0.png" alt="c2ae4429c3b3ecc8caa194b259090b0" style="zoom:67%;" />

尝试生成难度2：

![55d73a01ce80797b87a8cc5d2e84851](Pic/55d73a01ce80797b87a8cc5d2e84851.png)

尝试生成难度3：

![eb8bea6547d4074db072af6e0131e47](Pic/eb8bea6547d4074db072af6e0131e47.png)

<img src="Pic/c2ae4429c3b3ecc8caa194b259090b0-16880276004871.png" alt="c2ae4429c3b3ecc8caa194b259090b0" style="zoom:80%;" />

> 求解后的难度3为：
>
> <img src="Pic/928c146a5ed0fa960131de34d1071b8.png" alt="928c146a5ed0fa960131de34d1071b8" style="zoom:67%;" />

#### 4.5 控制挖空数量范围

同时使用参数`-n`和`-r`，指定生成数独游戏的数量和挖空范围。注意，挖空范围的两个数应用`-`符号链接。

| [para]  | -r                                                           |
| :------ | :----------------------------------------------------------- |
| mean    | 生成游戏中挖空的数量范围                                     |
| range   | 20-55                                                        |
| example | shudu.exe -n 20 -r 20-55 【生成20个挖空数在20~55之间的数独游戏，只有r和n一起使用才认为参数无误，否则请报错】 |

![image-20230628211708487](Pic/image-20230628211708487.png)

![image-20230628211801996](Pic/image-20230628211801996.png)

#### 4.6 生成唯一解游戏

同时使用参数`-n`与`-u`，即可指定生成游戏的数量，且它们具有唯一解

| [para]  | -u                                                           |
| :------ | :----------------------------------------------------------- |
| mean    | 生成游戏的解唯一                                             |
| example | shudu.exe -n 20 -u 【生成20个解唯一的数独游戏，只有u和n一起使用才认为参数无误，否则请报错】 |

![image-20230628211510814](Pic/image-20230628211510814.png)

成功生成了`question.txt`：

![image-20230628211538326](Pic/image-20230628211538326.png)

![image-20230628211729187](Pic/image-20230628211729187.png)

#### 4.7 参数乱序

在我们的程序中，参数的位置可以并不固定，且允许三个参数结合使用，例如：

- `\shudu.exe -r 20-30 -u -n 20`
- `\shudu.exe -n 20 -m 1 -u`

![image-20230629231718728](Pic/image-20230629231718728.png)

### 5 保存与加载

数独生成与求解的各种文件名解释如下：

- `final.txt`：默认终局文件
- `question.txt`：默认题目存储文件
- `ans.txt`：默认求解结果文件

建议用户使用一个固定目录来存储与管理这些文件，以免发生混乱。

## 质量分析

### 1 消除警告

我们首先分析警告：

1. 算数溢出

![image-20230629155237398](Pic/image-20230629155237398.png)

原代码为：

![image-20230629160729771](Pic/image-20230629160729771.png)

该警告指的是在计算 `startRow + i` 和 `startCol + j` 时，可能会发生整数溢出。这可能是因为编译器把 `startRow + i` 和` startCol + j` 这两个表达式的结果从 `int `（4字节）转换为` size_t` （在64位系统上是8字节）的过程中发生的。然而，由于` startRow`, `startCol`, `i`, 和`j `的值都在 0 到 9 之间，所以这里实际上不可能发生溢出。

但是为了消除，我们应该在做加法运算之前，就先把操作数转换为 `size_t`。这样可以确保加法运算的结果不会超过 `size_t` 可以表示的范围。

![image-20230629155724046](Pic/image-20230629155724046.png)

而另一处算数溢出是发生在打印进度条时：

![image-20230629160559865](Pic/image-20230629160559865.png)

源代码为

![image-20230629160822092](Pic/image-20230629160822092.png)

同理，我们使用`static_cast<size_t>`即可消除警告。

![image-20230629160905239](Pic/image-20230629160905239.png)

2. `time_T`转换到`unsigned int`，可能丢失数据

![image-20230629160529181](Pic/image-20230629160529181.png)

该问题的原代码为：

![image-20230629161007173](Pic/image-20230629161007173.png)

这个警告是由于将 `time_t` 类型的值转换为 `unsigned int` 类型时可能会丢失数据导致的。同样，我们可以使用`static_cast` 进行显式的类型转换。

修改代码为：

![image-20230629161208734](Pic/image-20230629161208734.png)

即可消除警告。

3. `_Rep`转换到`int`，可能丢失数据

![image-20230629161618676](Pic/image-20230629161618676.png)

发生警告的代码为：

![image-20230629161631435](Pic/image-20230629161631435.png)

本质上也是数据类型转换的问题，使用`static_cast`解决该问题。修改代码如下：

![image-20230629161747365](Pic/image-20230629161747365.png)

即可消除警告。

另一处同类型的警告的代码为：

![image-20230629162452925](Pic/image-20230629162452925.png)

修改为：

![image-20230629162553434](Pic/image-20230629162553434.png)

4. `double`转换到`int`，可能丢失数据

![image-20230629162316144](Pic/image-20230629162316144.png)

发生警告的代码为：

![image-20230629162245747](Pic/image-20230629162245747.png)

对于将 `double` 转换为 `int`，使用 `static_cast<int>` 来消除警告。

修改代码为：

![image-20230629162336304](Pic/image-20230629162336304.png)

另一处同类型的数据转换问题的警告为：

![image-20230629162640812](Pic/image-20230629162640812.png)

发生警告的代码为：

![image-20230629162728423](Pic/image-20230629162728423.png)

同样使用`static_cast`即可消除警告。

![image-20230629162812822](Pic/image-20230629162812822.png)

至此，所有警告已全部消除。

![0f5ace685dbc3c370381b87aeb0dda0](Pic/0f5ace685dbc3c370381b87aeb0dda0.png)

### 2 静态代码分析

使用VS2019中的Code Analysis进行分析，分析结果如下所示：

![image-20230629164813979](Pic/image-20230629164813979.png)

成功运行，没有警告。

### 3 代码规范检查

这里遵循的是谷歌的C++编程规范，链接为：https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/，大致规范为：

![img](https://img-blog.csdn.net/20180728195530773?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5eTYxNzUzMjc1MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

图源https://blog.csdn.net/zyy617532750/article/details/81264648

我们使用的代码规范检查工具为cpplint。

1. **GenerateHandler.cpp**

修改前：

![image-20230629173845942](Pic/image-20230629173845942.png)

总结错误如下：

1. 没有版权信息：应该在文件中添加版权信息行，例如："Copyright [year] <Copyright Owner>"。[legal/copyright]
2. 头文件包含顺序问题：C++系统头文件应该放在其他头文件之前，正确顺序应为：GenerateHandler.h、C系统头文件、C++系统头文件、其他头文件。[build/include_order]
3. 命名空间错误：不要使用命名空间的using-directives，应使用using-declarations。[build/namespaces]
4. 空格与注释问题：应在注释符 "//" 和注释之间添加空格，删除行末多余的空格，确保代码的一致性和可读性。[whitespace/comments] [whitespace/end_of_line]
5. 大括号和else语句问题：else语句应与前面的 "}" 在同一行上，如果有大括号，应该在两边都使用。这样可以提高代码的可读性。[whitespace/newline] [readability/braces]
6. 多余的空白行问题：应删除代码块末尾多余的空白行。[whitespace/blank_line]
7. 等号周围的空格问题：等号周围应该添加空格，提高代码的可读性。[whitespace/operators]
8. 强制类型转换问题：使用过时的C风格强制类型转换，建议使用`static_cast<int>(...)`进行类型转换。[readability/casting]
9. 文件末尾缺少换行符：文件末尾应包含一个换行符。[whitespace/ending_newline]

根据提示，我们逐行对代码进行修改，修改之后无error，如下图所示：

![image-20230629174011834](Pic/image-20230629174011834.png)

2. **GenerateHandler.h**

对于`GenerateHandler.h`，cpplint提示信息如下：

![image-20230629175516035](Pic/image-20230629175516035.png)

以上errors总结为：

1. 头文件包含顺序问题：C系统头文件应该在C++系统头文件之前。[build/include_order]
2. 头文件命名问题：在命名头文件时，应包含目录信息。[build/include_subdir]
3. 命名空间错误：不要使用命名空间的using-directives，应使用using-declarations。[build/namespaces]
4. 类中的private部分缩进问题：在GenerateHandler类中的private部分应该缩进一个空格。[whitespace/indent]
5. 注释与斜线问题：注释符 "//" 和注释之间应添加一个空格。[whitespace/comments]
6. 类中的public部分缩进问题：在GenerateHandler类中的public部分应该缩进一个空格。[whitespace/indent]
7. 类中的public部分前的空白行问题：在GenerateHandler类中的public部分前应有一个空白行。[whitespace/blank_line]

逐一解决以上问题，最终完全解决所有报错：

![image-20230629175432631](Pic/image-20230629175432631.png)

3. **InputHandler.cpp**

![image-20230629214921340](Pic/image-20230629214921340.png)

以上报错大致与前两个文件报错内容相同，逐一解决即可：

![image-20230629214903578](Pic/image-20230629214903578.png)

4. **InputHandler.h**

![image-20230629215509098](Pic/image-20230629215509098.png)

常规错误，解决即可：

![image-20230629215456167](Pic/image-20230629215456167.png)

5. **main.cpp**

![image-20230629180006503](Pic/image-20230629180006503.png)

消除以上错误：

![image-20230629180046754](Pic/image-20230629180046754.png)

6. **progree.cpp**

![image-20230629215943561](Pic/image-20230629215943561.png)

7. **progress.h**

![image-20230629220106145](Pic/image-20230629220106145.png)

8. **SolveHandler.cpp**

大部分错误我们之前已经遇到过，逐行修改即可：

![image-20230629180532793](Pic/image-20230629180532793.png)

9. **SolveHandler.h**

![image-20230629202315293](Pic/image-20230629202315293.png)

## 单元测试

使用Visual Studio自带的测试项目模板，关联Sudoku项目进行测试。需要创建一个新项目，使用本机单元测试项目模板，然后添加现有项，关联`main.obj`即可。

###  1 定义输入

首先我们定义一连串的字符串，以模拟正常可能的输入。正常输入如下所示：

![image-20230629211423676](Pic/image-20230629211423676.png)

```cpp
	int argc1, argc2, argc3, argc4;
	char** argv1, ** argv2, ** argv3, ** argv4, ** argv5, ** argv6, ** argv7;
	string path = "D:\\LessonProjects\\shudu\\";

	argc1 = 3;
	argc2 = 4;
	argc3 = 5;
	argc4 = 6;
	argv1 = new char* [3];//c
	argv2 = new char* [3];//s
	argv3 = new char* [3];//n
	argv4 = new char* [4];//n u
	argv5 = new char* [5];//n m
	argv6 = new char* [5];//n r
	argv7 = new char* [6];//n r u

	for (int i = 0; i < 3; i++) {
		argv1[i] = new char[30];
		argv2[i] = new char[30];
		argv3[i] = new char[30];
	}
	for (int i = 0; i < 4; i++) {
		argv4[i] = new char[30];

	}
	for (int i = 0; i < 5; i++) {
		argv5[i] = new char[30];
		argv6[i] = new char[30];
	}
	for (int i = 0; i < 6; i++) {
		argv7[i] = new char[30];
	}

	strcpy_s(argv1[0], 30, "shudu.exe");
	strcpy_s(argv1[1], 30, "-c");
	strcpy_s(argv1[2], 30, "100");

	strcpy_s(argv2[0], 30, "shudu.exe");
	strcpy_s(argv2[1], 30, "-s");
	strcpy_s(argv2[2], 30, "question.txt");

	strcpy_s(argv3[0], 30, "shudu.exe");
	strcpy_s(argv3[1], 30, "-n");
	strcpy_s(argv3[2], 30, "100");

	strcpy_s(argv4[0], 30, "shudu.exe");
	strcpy_s(argv4[1], 30, "-n");
	strcpy_s(argv4[2], 30, "10");
	strcpy_s(argv4[3], 30, "-u");

	strcpy_s(argv5[0], 30, "shudu.exe");
	strcpy_s(argv5[1], 30, "-n");
	strcpy_s(argv5[2], 30, "100");
	strcpy_s(argv5[3], 30, "-m");
	strcpy_s(argv5[4], 30, "3");

	strcpy_s(argv6[0], 30, "shudu.exe");
	strcpy_s(argv6[1], 30, "-n");
	strcpy_s(argv6[2], 30, "100");
	strcpy_s(argv6[3], 30, "-r");
	strcpy_s(argv6[4], 30, "20-55");

	strcpy_s(argv7[0], 30, "shudu.exe");
	strcpy_s(argv7[1], 30, "-n");
	strcpy_s(argv7[2], 30, "100");
	strcpy_s(argv7[3], 30, "-r");
	strcpy_s(argv7[4], 30, "20-55");
	strcpy_s(argv7[3], 30, "-u");
```

之后便可以开始各个部分的测试。

### 2 参数测试

1. 当参数为`-c`时，默认的数量为100，即生成100个游戏终盘。

   我们使用`InputHandler`的`GetNum`和`GetType`函数来测试`setAbsPath`和`check`函数是否正常。使用`setAbsPath`设置路径，并使用`check`函数将参数传入。首先验证是否正确接收到数量100这个数字，其次验证是否正确接收到参数为`-c`。如果都正确接收，函数会返回`true`，失败将显示错误信息，并返回`false`。

   ```cpp
   //测试InputHandler,参数为-c时
   		TEST_METHOD(TestMethod1)
   		{
   			InputHandler inputs;
   			inputs.setAbsPath(path);
   			inputs.check(argc1, argv1);
   			Assert::AreEqual(inputs.GetNum() == 100, true);
   			Assert::AreEqual(inputs.GetType1() == 'c', true);
   		}
   ```

2. 当参数为`-s`时，求解游戏。

   仍然使用`InputHandler`的`GetNum`和`GetType`函数进行测试，期望正确识别参数`-s`和文件路径。

   ```cpp
   //测试InputHandler, 参数为-s时
   		TEST_METHOD(TestMethod2)
   		{
   			InputHandler inputs;
   			inputs.setAbsPath(path);
   			inputs.check(argc1, argv2);
   			Assert::AreEqual(inputs.GetType1() == 's', true);
   		}
   ```

3. 当参数为`-n`时，生成数独游戏

   此时我们需要使用`inputs.generator`的`generate`函数来生成数独游戏。如果生成成功，将会返回`true`。且能正常识别参数`-n`。

   ```cpp
   TEST_METHOD(TestMethod3)
   		{
   			InputHandler inputs;
   			inputs.setAbsPath(path);
   			inputs.check(argc1, argv3);
   			bool abc = inputs.generator.generate(100, 18, 64, false);
   			Assert::AreEqual(inputs.GetType1() == 'n', true);
   			Assert::AreEqual(abc, true);
   		}
   ```

4. 命令行参数只有两个

   正常来说，命令行的参数至少为3个。若只传入两个参数，那么程序本身会输出错误提示，且参数类型被初始化后不能被修改，即一直为初始化的`y`。

   ```cpp
   //测试InputHandler，命令行参数不是2个
   		TEST_METHOD(TestMethod4)
   		{
   			argc1 = 2;
   			InputHandler inputs;
   			inputs.setAbsPath(path);
   			inputs.check(argc1, argv1);
   			Assert::AreEqual(inputs.GetType1() == 'y', true);
   		}
   ```

5. 参数不在给定范围中

   假设参数不是给定的6个可使用参数中的任何一个，为`x`，则参数的type不能被正确地赋值，和第四个相同：
   
   ```cpp
   //测试InputHandler，参数不是-c\-s\-n
   		TEST_METHOD(TestMethod5)
   		{
   			argv1[1][1] = 'x';
   			InputHandler inputs;
   			inputs.setAbsPath(path);
   			inputs.check(argc1, argv1);
   			Assert::AreEqual(inputs.GetType1() == 'y', true);
   		}
   ```
   
6. 测试生成数量

   ```cpp
   TEST_METHOD(TestMethod6)
   		{
   			argv1[2][0] = '-';
   			argv1[2][1] = '1';
   			InputHandler inputs;
   			inputs.setAbsPath(path);
   			inputs.check(argc1, argv1);
   			Assert::AreEqual(inputs.GetNum() == 1, true);
   		}
   ```

7. 测试能否生成数独终局

   调用generate函数，以生成数独终局。如果成功生成，则会返回`true`，失败将显示错误信息，并返回`false`。

   ```cpp
   //测试生成数独终局
   		TEST_METHOD(TestMethod7)
   		{
   			strcpy_s(argv1[2], 30, "1");
   			InputHandler inputs;
   			inputs.setAbsPath(path);
   			inputs.check(argc1, argv1);
   			bool a = inputs.generator.generate(inputs.GetNum(), 18, 64, false);
   			Assert::AreEqual(true, a);
   		}
   ```

8. 测试生成唯一解

   同上，需要调用generate函数。但是这里需要在`generate`函数中传入`true`，表明生成具有唯一解的游戏，成功生成将返回`true`，失败将显示错误信息，并返回`false`。

   ```cpp
   //测试生成唯一解
   		TEST_METHOD(TestMethod8)
   		{
   			InputHandler inputs;
   			inputs.setAbsPath(path);
   			inputs.check(argc2, argv4);
   			Assert::AreEqual(inputs.GetNum() == 10, true);
   			Assert::AreEqual(inputs.GetType1() == 'n', true);
   			Assert::AreEqual(inputs.GetType2() == 'u', true);
   			bool a = inputs.generator.generate(inputs.GetNum(),s 18, 64, true);
   			Assert::AreEqual(true, a);
   		}
   ```

9. 测试指定level

   同样，测试`-n`和`-m`参数能否被正确识别，数字是否被正确赋值。当参数`-m`为3时，挖空数量为`33~64`，成功创建游戏将返回`true`，失败将显示错误信息，并返回`false`。

   ```cpp
   //测试指定level
   		TEST_METHOD(TestMethod9)
   		{
   			InputHandler inputs;
   			inputs.setAbsPath(path);
   			inputs.check(argc3, argv5);
   			Assert::AreEqual(inputs.GetNum() == 100, true);
   			Assert::AreEqual(inputs.GetType1() == 'n', true);
   			Assert::AreEqual(inputs.GetType2() == 'm', true);
   			Assert::AreEqual(inputs.GetLevel() == 3, true);
   			bool a = inputs.generator.generate(inputs.GetNum(), 33, 64, true);
   			Assert::AreEqual(true, a);
   		}
   ```

10. 测试指定挖空数量

   同样调用generate函数，但是挖空范围由`GetRange`获取，成功生成游戏将返回`true`，失败将显示错误信息，并返回`false`。

   ```cpp
   //测试指定挖空数量
   		TEST_METHOD(TestMethod10)
   		{
   			InputHandler inputs;
   			inputs.setAbsPath(path);
   			inputs.check(argc3, argv6);
   			Assert::AreEqual(inputs.GetNum() == 100, true);
   			Assert::AreEqual(inputs.GetType1() == 'n', true);
   			Assert::AreEqual(inputs.GetType2() == 'r', true);
   			Assert::AreEqual(inputs.GetRange1() == 20, true);
   			Assert::AreEqual(inputs.GetRange2() == 30, true);
   			bool a = inputs.generator.generate(inputs.GetNum(), inputs.GetRange1(), inputs.GetRange2(), true);
   			Assert::AreEqual(true, a);
   		}
   ```

11. 测试该数独可以解

    测试`solveSudoku`函数，确保对于一个给定的数独游戏，它能否正确地找到解。

    ```cpp
    //测试该数独可以解
    		TEST_METHOD(TestMethod11)
    		{
    			Generatehandler handler;
    			vector<vector<int>> board = {
    				{5, 3, '$', '$', 7, '$', '$', '$', '$'},
    				{6, '$', '$', 1, 9, 5, '$', '$', '$'},
    				{'$', 9, 8, '$', '$', '$', '$', 6, '$'},
    				{8, '$', '$', '$', 6, '$', '$', '$', 3},
    				{4, '$', '$', 8, '$', 3, '$', '$', 1},
    				{7, '$', '$', '$', 2, '$', '$', '$', 6},
    				{'$', 6, '$', '$', '$', '$', 2, 8, '$'},
    				{'$', '$', '$', 4, 1, 9, '$', '$', 5},
    				{'$', '$', '$', '$', 8, '$', '$', 7, 9}
    			};
    			Assert::AreEqual(handler.solveSudoku(board), true); // 该数独游戏可以解
    		}
    ```

12. 确保生成9*9游戏且有解

    测试`generateSudoku`函数，确保它能生成一个9x9的数独游戏，并且这个游戏有解。

    ```cpp
    TEST_METHOD(TestMethod12)
    		{
    			Generatehandler handler;
    			vector<vector<int>> board;
    			handler.generateSudoku(board);
    
    			// 检查是否生成的是9x9的数独游戏
    			size_t nine = 9;
    			Assert::AreEqual(board.size(), nine);
    			for (const auto& row : board) {
    				Assert::AreEqual(row.size(), nine);
    			}
    
    			// 检查是否有解
    			Assert::AreEqual(handler.solveSudoku(board), true);
    		}
    ```

13. 测试能否放置数字

    测试`isValid`函数，确保在给定的行、列和数字情况下，能否正确地验证是否可以放置这个数字。

    ```cpp
    //测试能否放置数字
    		TEST_METHOD(TestMethod13)
    		{
    			Generatehandler handler;
    			vector<vector<int>> board = {
    				{5, 3, '$', '$', 7, '$', '$', '$', '$'},
    				{6, '$', '$', 1, 9, 5, '$', '$', '$'},
    				{'$', 9, 8, '$', '$', '$', '$', 6, '$'},
    				{8, '$', '$', '$', 6, '$', '$', '$', 3},
    				{4, '$', '$', 8, '$', 3, '$', '$', 1},
    				{7, '$', '$', '$', 2, '$', '$', '$', 6},
    				{'$', 6, '$', '$', '$', '$', 2, 8, '$'},
    				{'$', '$', '$', 4, 1, 9, '$', '$', 5},
    				{'$', '$', '$', '$', 8, '$', '$', 7, 9}
    			};
    
    			Assert::AreEqual(handler.isValid(board, 0, 2, 1), true); // 5x5位置可以放1
    			Assert::AreEqual(handler.isValid(board, 0, 0, 6), false); // 5x5位置不能放6
    		}
    ```

14. 6个参数

    当输入的参数为：`-n 100 -r 20-55 -u`时

    ```cpp
    TEST_METHOD(TestMethod14)
    		{
    			InputHandler inputs;
    			inputs.setAbsPath(path);
    			inputs.check(argc4, argv7);
    			Assert::AreEqual(inputs.GetNum() == 100, true);
    			Assert::AreEqual(inputs.GetType1() == 'n', true);
    			Assert::AreEqual(inputs.GetType2() == 'r', true);
    			Assert::AreEqual(inputs.GetType3() == 'u', true);
    			assert(inputs.GetRange1() == 20, true);
    			assert(inputs.GetRange2() == 55, true);
    			bool a = inputs.generator.generate(inputs.GetNum(), inputs.GetType1(), inputs.GetType2(), true);
    			Assert::AreEqual(true, a);
    
    		}
    ```

15. 参数乱序

    当输入的参数为：`-u  -n 100 -m 1`时

    ```
    TEST_METHOD(TestMethod16)
    		{
    			strcpy_s(argv7[0], 30, "shudu.exe");
    			strcpy_s(argv7[1], 30, "-n");
    			strcpy_s(argv7[2], 30, "100");
    			strcpy_s(argv7[3], 30, "-r");
    			strcpy_s(argv7[4], 30, "20-55");
    			strcpy_s(argv7[3], 30, "-u");
    			InputHandler inputs;
    			inputs.setAbsPath(path);
    			bool abc = inputs.generator.generate(1, 20, 30, false);
    			Assert::AreEqual(abc, true);
    		}
    ```

单元测试全部通过：

![image-20230630002320753](Pic/image-20230630002320753.png)

除此之外，我们还通过命令行对代码进行了测试，以下是各种情况的执行情况：

| 编号 | 命令行参数           | 结果                                                         |
| ---- | -------------------- | ------------------------------------------------------------ |
| 1    | -c 1                 | 生成正确                                                     |
| 2    | -c 100               | 生成正确                                                     |
| 3    | -c 1000000           | 生成正确                                                     |
| 4    | -c 1000001           | 输出“请输入1-1000000的数字！”                                |
| 5    | -c 0                 | 输出“请输入1-1000000的数字！”                                |
| 6    | -cc 12               | 输出“输入不合法，请使用 ‘suodoku.exe -c 数字’ 或 ‘sudoku.exe -s 文件名’ 格式输入。” |
| 7    | -c x                 | 输出“请检查-c参数是否为数字。”                               |
| 8    | -s sudoku.txt        | 正确求解                                                     |
| 9    | -s illegalsudoku.txt | 输出“该数独无法求解！”                                       |
| 10   | -s unexistfile.txt   | 输出“请检查-s参数文件是否存在。”                             |

| 生成个数      | 预期输出 | 实际输出 |
| ------------- | -------- | -------- |
| 1             | 1        | 1        |
| 20            | 20       | 20       |
| 100           | 100      | 100      |
| 1000          | 1000     | 1000     |
| 1000000       | 1000000  | 1000000  |
| 数独求解 编号 | 预期输出 | 实际输出 |
| 1             | 正确     | 正确     |
| 2             | 正确     | 正确     |
| 3             | 正确     | 正确     |
| 4             | 正确     | 正确     |
| 5             | 正确     | 正确     |



## 覆盖率报告

在VS2019中使用OpenCppCoverage进行分析，分析结果如下所示：



## 性能分析

